#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <LittleFS.h>
#include "time.h"

// ==== USER SETTINGS ====
const char* WIFI_SSID = "DPhone";
const char* WIFI_PASS = "";
const char* NEOCITIES_API_KEY = "";
const char* REMOTE_FILENAME = "logs/data.csv";  // Neocities will create nested folders if needed

const int   ADC_PIN = 36;   // Pressure transducer on GPIO36
const float VREF    = 3.3f; // Effective reference (0–4095 ADC)

// Transducer scaling
const float MAX_DEPTH_M = 5.0;   // Sensor range 0–5 m
const float MAX_ADC_V   = 3.3;   // Voltage span after divider

// Timing
unsigned long lastSample = 0;
const unsigned long SAMPLE_MS  = 10000;  // 10 s between samples
unsigned long lastUpload = 0;
const unsigned long UPLOAD_MS  = 20000;  // 20 s between uploads

const char* CSV_HEADER = "timestamp,depth_m\n";

// ==== Time (Hamilton, NZ) ====
const char* ntpServer        = "pool.ntp.org";
const long  gmtOffset_sec    = 12 * 3600;  // NZST = UTC+12
const int   daylightOffset_sec = 0;     // +1h in summer (NZDT), change to "3600" to adjust

// Create UART2 on pins 16 (RX) and 17 (TX)
HardwareSerial Serial2Port(2);

void logBoth(const String &msg) {
  Serial.print(msg);
  Serial2Port.print(msg);
}
void logBothln(const String &msg) {
  Serial.println(msg);
  Serial2Port.println(msg);
}

String currentTimestamp() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) return "1970-01-01 00:00:00";
  char buf[25];
  strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &timeinfo);
  return String(buf);
}

// Convert ADC → volts → depth in meters
float readDepth() {
  int raw = analogRead(ADC_PIN);           // 0–4095
  float volts = (raw * VREF) / 4095.0f;
  float depth = (volts / MAX_ADC_V) * MAX_DEPTH_M;
  return depth;
}

bool createFreshCSV() {
  if (!LittleFS.begin(false)) {
    if (!LittleFS.begin(true)) {
      logBothln("LittleFS mount failed");
      return false;
    }
  }
  logBothln("Formatting LittleFS (erasing all files)...");
  if (!LittleFS.format()) {
    logBothln("LittleFS.format() failed");
    return false;
  }
  LittleFS.end();
  if (!LittleFS.begin(false)) {
    logBothln("LittleFS re-mount failed after format");
    return false;
  }
  File f = LittleFS.open("/data.csv", FILE_WRITE);
  if (!f) {
    logBothln("Failed to create /data.csv");
    return false;
  }
  f.print(CSV_HEADER);
  f.close();
  logBothln("Created fresh /data.csv with header");
  return true;
}

void appendRow() {
  File f = LittleFS.open("/data.csv", FILE_APPEND);
  if (!f) {
    logBothln("Failed to open CSV for appending");
    return;
  }
  String row = currentTimestamp() + "," + String(readDepth(), 2) + "\n";
  f.print(row);
  f.close();
  logBoth("Appended row: "); logBothln(row);
}

bool uploadToNeocities() {
  File f = LittleFS.open("/data.csv", FILE_READ);
  if (!f) {
    logBothln("No CSV file to upload");
    return false;
  }
  size_t size = f.size();
  std::unique_ptr<uint8_t[]> buf(new uint8_t[size]);
  f.read(buf.get(), size);
  f.close();

  String boundary = "----ESP32Boundary";
  String start =
    "--" + boundary + "\r\n"
    "Content-Disposition: form-data; name=\"" + String(REMOTE_FILENAME) + "\"; filename=\"data.csv\"\r\n"
    "Content-Type: text/csv\r\n\r\n";
  String end = "\r\n--" + boundary + "--\r\n";

  size_t len = start.length() + size + end.length();
  std::unique_ptr<uint8_t[]> body(new uint8_t[len]);
  memcpy(body.get(), start.c_str(), start.length());
  memcpy(body.get() + start.length(), buf.get(), size);
  memcpy(body.get() + start.length() + size, end.c_str(), end.length());

  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;
  if (!http.begin(client, "https://neocities.org/api/upload")) {
    logBothln("Failed to connect to Neocities");
    return false;
  }
  http.addHeader("Authorization", String("Bearer ") + NEOCITIES_API_KEY);
  http.addHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
  int code = http.POST(body.get(), len);
  http.end();
  logBoth("Upload HTTP "); logBothln(String(code));
  return (code >= 200 && code < 300);
}

void setup() {
  Serial.begin(9600);
  Serial2Port.begin(9600, SERIAL_8N1, 16, 17); // RX=16, TX=17
  delay(100);

  if (!createFreshCSV()) {
    logBothln("Filesystem init failed; halting.");
    while (true) delay(100);
  }

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  logBoth("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) { delay(500); logBoth("."); }
  logBothln("\nConnected to WiFi");
  logBoth("IP: "); logBothln(WiFi.localIP().toString());

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  analogReadResolution(12);
  analogSetPinAttenuation(ADC_PIN, ADC_11db);

  appendRow();
  uploadToNeocities();

  unsigned long now = millis();
  lastSample = now;
  lastUpload = now;
}

void loop() {
  unsigned long now = millis();

  if (now - lastSample >= SAMPLE_MS) {
    lastSample = now;
    appendRow();
  }

  if (now - lastUpload >= UPLOAD_MS && WiFi.status() == WL_CONNECTED) {
    lastUpload = now;
    uploadToNeocities();
  }
}
